--- tb_userspace.c	2010-06-15 20:42:46.000000000 +0800
+++ tb_light.c	2010-06-15 20:49:20.000000000 +0800
@@ -19,6 +19,10 @@
         	int tun_mode;	/*0 for 6to4, 1 for tunnelbroker, 2 for isatap*/
 	};
 
+void printip(int ipaddr) {
+        printf("%d.%d.%d.%d", 0x000000ff&ipaddr, (0x0000ff00&ipaddr)>>8, (0x00ff0000&ipaddr)>>16 ,(0xff000000&ipaddr)>>24);
+}//Only for debug
+
 int tun_create(char *dev, int flags)
 {
     struct ifreq ifr;
@@ -38,19 +42,14 @@
     return fd;
 }
 
-void printip(int ipaddr) {
-	printf("%d.%d.%d.%d", 0x000000ff&ipaddr, (0x0000ff00&ipaddr)>>8, (0x00ff0000&ipaddr)>>16 ,(0xff000000&ipaddr)>>24);
-}//Only for debug
-
 void s2t_thread(void *s2targs) {
-	int sockv6, tun, ret, res, remote_ip, leniphead, tun_mode;
+	int sockv6, tun, ret, res, remote_ip, leniphead;
 	unsigned char bufsock[4096];
 	struct tun_pi pi = {0, htons(ETH_P_IPV6)};
 	/*pi is sth. like link-layer header for device tun and should be set type IPV6*/
 	sockv6 = (*(struct Threadargs *)s2targs).sockv6;
 	tun = (*(struct Threadargs *)s2targs).tun;
 	remote_ip = (*(struct Threadargs *)s2targs).remote_ip;
-	tun_mode = (*(struct Threadargs *)s2targs).tun_mode;
 	while (1) {
                 res = recv(sockv6, bufsock, sizeof(bufsock), 0);
                 if (res < 0) {
@@ -62,38 +61,6 @@
 			printf("IPv4 header too long\r\n");
 			continue;
 		}
-		if (tun_mode==1) {/*Only accept package with source IPv4 addr the same as tunnel server's*/
-			if ( *(int *)(&bufsock[12])!=remote_ip ) {
-				printf("s2t:Drop package from source IPv4 ");
-				printip(*(int *)(&bufsock[12]));
-				printf(" not the relay server");
-				printip(remote_ip);
-				printf("\r\n");
-				continue;
-			}
-		}
-		else if (tun_mode==2) {/*In ISATAP mode, we should accept package (IPv6)prefix:0:5efe:xx.xx.xx.xx in (IPv4)xx.xx.xx.xx*/
-			if ( ( *(int *)(&bufsock[12])!=remote_ip ) && (( *(int *)(&bufsock[(leniphead+16)])!=0xfe5e0000) || ( *(int *)(&bufsock[12])!=*(int *)(&bufsock[leniphead+20])) ) ) {
-				printf("s2t:Drop package from source IPv4 ");
-				printip(*(int *)(&bufsock[12]));
-				printf(" do not corresponds its IPv6 address.\r\n");
-				continue;
-			}
-		}
-		else if ((tun_mode==0) && ( *(int *)(&bufsock[12])!=remote_ip) ) {/*In 6to4 mode, (IPv6)2002:xxxx:xxxx::/48 in (IPv4)xx.xx.xx.xx should be accepted*/
-			if ( *(short *)(&bufsock[(leniphead+8)])!=0x0220) {
-				printf("s2t:Drop package from source IPv4 ");
-                                printip(*(int *)(&bufsock[12]));
-                                printf(" do not corresponds its IPv6 address.\r\n");
-				continue;
-			}
-			else if( (*(int *)(&bufsock[12]))!=(*(int *)(&bufsock[(leniphead+10)]))) {
-				printf("s2t:Drop package from source IPv4 ");
-                                printip(*(int *)(&bufsock[12]));
-                                printf(" do not corresponds its IPv6 address.\r\n");
-				continue;
-			}
-		}
 		ret = res - leniphead;
 		memcpy(&bufsock[leniphead-sizeof(struct tun_pi)], &pi, sizeof(struct tun_pi));
 		ret = write(tun, &bufsock[leniphead-sizeof(struct tun_pi)], ret + sizeof(struct tun_pi));
@@ -102,13 +69,12 @@
 }
 
 void t2s_thread(void *t2sargs) {
-	int sockv6, tun, ret, res, remote_ip, leniphead, tun_mode;
+	int sockv6, tun, ret, res, remote_ip, leniphead;
 	unsigned char buftun[4096];
 	unsigned char tmp[4096];
 	sockv6 = (*(struct Threadargs *)t2sargs).sockv6;
         tun = (*(struct Threadargs *)t2sargs).tun;
 	remote_ip = (*(struct Threadargs *)t2sargs).remote_ip;
-	tun_mode = (*(struct Threadargs *)t2sargs).tun_mode;
 	struct sockaddr_in remoteaddr;
 	remoteaddr.sin_family = AF_INET;
 	remoteaddr.sin_port = htons(IPPROTO_IPV6);
@@ -120,19 +86,6 @@
 			continue;
 		}
 		remoteaddr.sin_addr.s_addr = remote_ip;
-		switch (tun_mode) {
-			case 0:
-				if (*(short *)(&buftun[(sizeof(struct tun_pi)+24)])==0x0220) {
-					remoteaddr.sin_addr.s_addr = *(int *)(&buftun[(sizeof(struct tun_pi)+26)]);
-				}/*send package directly to (IPv4)xx.xx.xx.xx other than default gw 192.88.99.1 when handing (IPv6)2002:xxxx:xxxx::/48 package*/
-				break;
-			case 1: break;
-			case 2:
-				if ( (*(int *)(&buftun[(sizeof(struct tun_pi)+24)])==*(int *)(&buftun[(sizeof(struct tun_pi)+8)])) && (*(int *)(&buftun[(sizeof(struct tun_pi)+28)])==*(int *)(&buftun[(sizeof(struct tun_pi)+12)])) && (*(int *)(&buftun[(sizeof(struct tun_pi)+32)])==*(int *)(&buftun[(sizeof(struct tun_pi)+16)])) && (*(int *)(&buftun[(sizeof(struct tun_pi)+16)])==0xfe5e0000)) {
-					remoteaddr.sin_addr.s_addr = *(int *)(&buftun[(sizeof(struct tun_pi)+36)]);
-				}/*In ISATAP mode, IPv6 packages to /64 neighbours are send directly to their IPv4 address without relay*/
-				break;
-		}
 		res = sendto(sockv6, &buftun[sizeof(struct tun_pi)], ret, 0 ,(struct sockaddr *)&remoteaddr, sizeof(struct sockaddr));
 		printf("t2s: %d/%d bytes\r\n", ret ,res);
 	}
